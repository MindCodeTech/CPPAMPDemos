/*
	FOR GETTING MORE INFORMATION ABOUT THIS CODE PLEASE CHECK http://directx11-1-gameprogramming.azurewebsites.net/
	THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
	ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
	THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
	PARTICULAR PURPOSE.
	Copyright (c) Microsoft Corporation. All rights reserved

	File Name        : Shader.cpp
	Generated by     : Pooya Eimandar (http://Pooya-Eimandar.com/)
	File Description :
*/

#include "pch.h"
#include "FrameWork\DXHelper.h"
#include "..\Shader.h"

using namespace Platform;
using namespace Concurrency;
using namespace DirectX;

Shader::Shader(Graphics3D G3D, bool CreateLight)
{
	this->G3D = G3D;
	this->objectInfo = new ObjectInfo();
	this->createLight = CreateLight;
}

task<void> Shader::LoadAsync(String^ VSFileName, String^ PSFileName)
{
	return LoadAsync(VSFileName, PSFileName, nullptr, nullptr, nullptr,
		VertexTypes::Types::PositionNormalTangentColorTexture);
}

task<void> Shader::LoadAsync(String^ VSFileName, String^ PSFileName, Platform::String^ GSFileName, Platform::String^ HSFileName,
							 Platform::String^ DSFileName, VertexTypes::Types vertexType)
{
	std::vector<task<void>> tasks;

#pragma region Load Vertex Shader

	auto loadedVS = DXHelper::ReadFileAsync(VSFileName);
	auto VSTask = loadedVS.then([=](Platform::Array<byte>^ VSBytes) 
	{
		auto hr = this->G3D.device->CreateVertexShader(VSBytes->Data, VSBytes->Length, nullptr, &this->vertexShader);
		DXHelper::ThrowIfFailed(hr);

		if( vertexType == VertexTypes::PositionColor)
		{
			D3D11_INPUT_ELEMENT_DESC LayoutDesc[] =
			{
				{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT    , 0, 0                           , D3D11_INPUT_PER_VERTEX_DATA, 0 },
				{ "COLOR"   , 0, DXGI_FORMAT_R32G32B32A32_FLOAT , 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
			};
			CreateLayout(VSBytes, LayoutDesc, ARRAYSIZE(LayoutDesc));
		}
		else if( vertexType == VertexTypes::PositionTexture)
		{
			D3D11_INPUT_ELEMENT_DESC LayoutDesc[] =
			{
				{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT    , 0, 0                           , D3D11_INPUT_PER_VERTEX_DATA, 0 },
				{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT       , 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
			};
			CreateLayout(VSBytes, LayoutDesc, ARRAYSIZE(LayoutDesc));
		}
		else if( vertexType == VertexTypes::PositionNormalTexture)
		{
			D3D11_INPUT_ELEMENT_DESC LayoutDesc[] =
			{
				{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT    , 0, 0                           , D3D11_INPUT_PER_VERTEX_DATA, 0 },
				{ "NORMAL"  , 0, DXGI_FORMAT_R32G32B32_FLOAT    , 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
				{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT       , 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
			};
			CreateLayout(VSBytes, LayoutDesc, ARRAYSIZE(LayoutDesc));
		}
		else if( vertexType == VertexTypes::PositionNormalTangentColorTexture)
		{
			D3D11_INPUT_ELEMENT_DESC LayoutDesc[] =
			{
				{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT    , 0, 0                           , D3D11_INPUT_PER_VERTEX_DATA, 0 },
				{ "NORMAL"  , 0, DXGI_FORMAT_R32G32B32_FLOAT    , 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
				{ "TANGENT" , 0, DXGI_FORMAT_R32G32B32A32_FLOAT , 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
				{ "COLOR"   , 0, DXGI_FORMAT_B8G8R8A8_UNORM     , 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
				{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT       , 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
			};
			CreateLayout(VSBytes, LayoutDesc, ARRAYSIZE(LayoutDesc));
		}
		else
		{
			throw ref new Exception(0, "Unknown vertex format");
		}
	});
	tasks.push_back(VSTask);

#pragma endregion

#pragma region Load Geometry Shader

	bool HasGShader = !GSFileName->IsEmpty();
	if (HasGShader)
	{		
		auto loadedGS = DXHelper::ReadFileAsync(GSFileName);
		auto GSTask = loadedGS.then([this](Platform::Array<byte>^ GSBytes) 
		{
			auto hr = this->G3D.device->CreateGeometryShader(GSBytes->Data, GSBytes->Length, nullptr, &this->geometryShader);
			DXHelper::ThrowIfFailed(hr);
		});
		tasks.push_back(GSTask);
	}

#pragma endregion

#pragma region Load Hull Shader

	bool HasHShader = !HSFileName->IsEmpty();
	if (HasHShader)
	{		
		auto loadedHS = DXHelper::ReadFileAsync(HSFileName);
		auto HSTask = loadedHS.then([this](Platform::Array<byte>^ GSBytes) 
		{
			auto hr = this->G3D.device->CreateHullShader(GSBytes->Data, GSBytes->Length, nullptr, &this->hullShader);
			DXHelper::ThrowIfFailed(hr);
		});
		tasks.push_back(HSTask);
	}

#pragma endregion

#pragma region Load Domain Shader

	bool HasDShader = !DSFileName->IsEmpty();
	if (HasDShader)
	{		
		auto loadedDS = DXHelper::ReadFileAsync(DSFileName);
		auto DSTask = loadedDS.then([this](Platform::Array<byte>^ DSBytes) 
		{
			auto hr = this->G3D.device->CreateDomainShader(DSBytes->Data, DSBytes->Length, nullptr, &this->domainShader);
			DXHelper::ThrowIfFailed(hr);
		});
		tasks.push_back(DSTask);
	}

#pragma endregion

#pragma region Load Pixel Shader

	auto loadedPS = DXHelper::ReadFileAsync(PSFileName);
	auto PSTask = loadedPS.then([this](Platform::Array<byte>^ PSBytes) 
	{
		auto hr = this->G3D.device->CreatePixelShader(PSBytes->Data, PSBytes->Length, nullptr, &this->pixelShader);
		DXHelper::ThrowIfFailed(hr);
	});
	tasks.push_back(PSTask);

#pragma endregion

	return when_all(tasks.begin(), tasks.end()).then([this] ()
	{
#pragma region When all done do

		auto hr = this->objectInfo->Load(G3D);
		DXHelper::ThrowIfFailed(hr);

		if (this->createLight)
		{
			this->lightInfo = new LightInfo();
			this->pixelColor = new PixelColor();

			hr = this->lightInfo->Load(G3D);
			DXHelper::ThrowIfFailed(hr);

			this->lightInfo->LPos = XMFLOAT4(1.0f, 0.0f, 0.0f, 1.0f);
			this->lightInfo->La = XMFLOAT3(0.4f, 0.4f, 0.4f);
			this->lightInfo->Ld = XMFLOAT3(0.8f, 0.8f, 0.8f);
			this->lightInfo->Ls = XMFLOAT3(0.0f, 1.0f, 1.0f);
			this->lightInfo->Ka = XMFLOAT3(0.4f, 0.4f, 0.4f);
			this->lightInfo->Kd = XMFLOAT3(0.0f, 0.9f, 0.9f);
			this->lightInfo->Ks = XMFLOAT3(0.0f, 1.0f, 1.0f);
			this->lightInfo->SpecPower = 30;

			this->lightInfo->Update(G3D);
			SetLightInfoCB();

			hr = this->pixelColor->Load(G3D);
			DXHelper::ThrowIfFailed(hr);
		}
#pragma endregion
	});
}

void Shader::CreateLayout( Array<byte>^ VSBytes, const D3D11_INPUT_ELEMENT_DESC* LayoutDesc , UINT NumElements)
{
	auto hr	= this->G3D.device->CreateInputLayout(
		LayoutDesc,
		NumElements,
		VSBytes->Data,
		VSBytes->Length,
		&this->inputLayout);

	DXHelper::ThrowIfFailed(hr);
}

void Shader::SetObjectInfoCB()
{
	if (this->objectInfo == nullptr) return;
	this->G3D.context->VSSetConstantBuffers(0,1, this->objectInfo->CBuffer.GetAddressOf());
	this->G3D.context->GSSetConstantBuffers(0,1, this->objectInfo->CBuffer.GetAddressOf());
	this->G3D.context->HSSetConstantBuffers(0,1, this->objectInfo->CBuffer.GetAddressOf());
}

void Shader::SetLightInfoCB()
{
	if (this->lightInfo == nullptr) return;
	this->G3D.context->PSSetConstantBuffers(1,1, this->lightInfo->CBuffer.GetAddressOf());
}

void Shader::SetPixelColorCB()
{
	if (this->pixelColor == nullptr) return;
	this->G3D.context->PSSetConstantBuffers(2,1, this->pixelColor->CBuffer.GetAddressOf());
}

void Shader::Apply()
{
	this->G3D.context->IASetInputLayout(this->inputLayout.Get());
	this->G3D.context->VSSetShader(this->vertexShader.Get(), nullptr, 0);
	this->G3D.context->GSSetShader(this->geometryShader != nullptr ? this->geometryShader.Get() : NULL, nullptr, 0);
	this->G3D.context->HSSetShader(this->hullShader != nullptr ? this->hullShader.Get() : NULL, nullptr, 0);
	this->G3D.context->DSSetShader(this->domainShader != nullptr ? this->domainShader.Get() : NULL, nullptr, 0);
	this->G3D.context->PSSetShader(this->pixelShader.Get(), nullptr, 0);
}

void Shader::SetParameter(Texture^ texture, UINT StartSLot, UINT NumViews)
{
	this->G3D.context->PSSetShaderResources(StartSLot, NumViews, texture->TextureView);
	this->G3D.context->PSSetSamplers(StartSLot, NumViews, texture->Sampler);
}

void Shader::Unload()
{
	SafeDelete(this->objectInfo);
	SafeDelete(this->lightInfo);
	SafeDelete(this->pixelColor);
}

