/*
	FOR GETTING MORE INFORMATION ABOUT THIS CODE PLEASE CHECK http://directx11-1-gameprogramming.azurewebsites.net/ 
	THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
	ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
	THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
	PARTICULAR PURPOSE.
    Copyright (c) Microsoft Corporation. All rights reserved

	File Name        : SimpleScene.cpp
	Generated by     : Pooya Eimandar (http://Pooya-Eimandar.com/)
	File Description : 
 */

#include "pch.h"
#include "SimpleScene.h"
#include "Framework/Input/InputManager.h"

#define MaxThreads 4
#define MaxModels  100

HANDLE							beginEvent[MaxThreads] = {NULL};
HANDLE							endEvent[MaxThreads] = {NULL};
ID3D11CommandList*				perSceneCommandList[MaxThreads]  = {NULL};
ComPtr<ID3D11DeviceContext1>    deferredContext[MaxThreads] = {NULL};  

using namespace DX;
using namespace std;
using namespace Concurrency;
using namespace Windows::System;

SimpleScene::SimpleScene() : loadingComplete(false)
{
	this->BackColor[0] = 0.0f;
	this->BackColor[1] = 0.478f;
	this->BackColor[2] = 0.8f;
	this->BackColor[3] = 1.0f;
}

void SimpleScene::InitializeThreads()
{
	HRESULT hr;
	vector<task<void>> tasks;

	this->batchSize = (int)(MaxModels / MaxThreads);
	int startIndex = 0, stopIndex = 0;

	for (int i = 0; i< MaxThreads; ++i)
	{
		beginEvent[i] = CreateEventExW( NULL, NULL, NULL, EVENT_ALL_ACCESS );
		endEvent[i] = CreateEventExW( NULL, NULL, NULL, EVENT_ALL_ACCESS );
		hr = GDevice.d3dDevice->CreateDeferredContext1( 0, &deferredContext[i] );
		ThrowIfFailed(hr);

		startIndex = this->batchSize * i;
		stopIndex +=  this->batchSize;
		if (stopIndex + this->batchSize > MaxModels)
		{
			stopIndex  = MaxModels;
		}

		auto t = create_task([this, startIndex, stopIndex, i]() -> void
		{
			while (true)
			{
				// Wait for main thread to signal ready
				OutputDebug("wait for begin event\n");
				WaitForSingleObjectEx( beginEvent[i], INFINITE, false );

				deferredContext[i]->ClearState();
				deferredContext[i]->OMSetRenderTargets(1, this->renderTargetView.GetAddressOf(), this->depthStencilView.Get() );
				
				//Start rendering
				this->modelManager->RenderModels(deferredContext[i].Get(), startIndex, stopIndex);

				ID3D11CommandList*& pd3dCommandList = perSceneCommandList[i];
				deferredContext[i]->FinishCommandList( false, &pd3dCommandList);

				// Tell main thread command list is finished
				OutputDebug("signal for end event\n");
				SetEvent( endEvent[i] );
			}
		});
		tasks.push_back(t);

	}

	when_all(begin(tasks), end(tasks));

	OutputDebug("task started\n");
}

void SimpleScene::Load()
{
	this->spriteBatch = ref new SpriteBatch();
	this->spriteFont = ref new SpriteFont();
	this->spriteFont->Load();
	this->perf = ref new Perf();

	Camera = ref new FirstCamera();
	this->modelManager = ref new ModelManager();
	int row = 0, col = 0;
	for (int i = 0; i < MaxModels; ++i, row++)
	{
		this->modelManager->LoadModel(L"Scene.cmo");
		this->modelManager->ActiveIndex = i;
		if (i % 5 == 0)
		{
			col--;
			row = 0;
		}
		this->modelManager->UpdateActiveModel(XMFLOAT3(row * 30 - 50, -10, col * 50 + 30 ), i );
	}

	InitializeThreads();
}

void SimpleScene::Unload()
{
}

void SimpleScene::Update(float TotalTime, float DeltaTime)
{
	this->perf->Update(TotalTime, DeltaTime);
	this->BackColor[1] += 0.01f;
	if (this->BackColor[1] > 1.0f)
	{
		this->BackColor[1] = 0.0f;
	}

	Camera->Update(DeltaTime);
	this->modelManager->UpdateModels(DeltaTime);

	this->MSG = L"Total triangles : " + this->modelManager->ActiveTotalTriangles.ToString();
}

void SimpleScene::Render()
{
	auto context = GDevice.d3dContext.Get();

	context->OMSetRenderTargets(1, this->renderTargetView.GetAddressOf(), this->depthStencilView.Get() );
	context->ClearRenderTargetView(this->renderTargetView.Get(), this->BackColor);
	context->ClearDepthStencilView(this->depthStencilView.Get(), D3D11_CLEAR_DEPTH, 1.0f, 0 );

	for (int i=0; i< MaxThreads; ++i)
	{
		// signal ready for scene kickoff
		OutputDebug("signal for begin event\n");
		SetEvent( beginEvent[i]);
	}

	OutputDebug("wait for end event\n");
	// wait for completion
	auto result = WaitForMultipleObjectsEx(
		MaxThreads, 
		endEvent, 
		true, 
		INFINITE,
		false);

	switch (result)
	{
	default:
		break;
	case WAIT_OBJECT_0: 
		OutputDebug("WAIT_OBJECT_0\n");
		break;
	case WAIT_ABANDONED_0:
		OutputDebug("WAIT_ABANDONED_0\n");
		break;
	case WAIT_IO_COMPLETION:
		OutputDebug("WAIT_IO_COMPLETION\n");
		break;
	case WAIT_TIMEOUT:
		OutputDebug("WAIT_TIMEOUT\n");
		break;
	case WAIT_FAILED:
		OutputDebug("WAIT_FAILED\n");
		break;
	}
	auto err = GetLastError();
	OutputDebug("all done\n");

	//execute all command lists
	for ( int iInstance = 0; iInstance < MaxThreads; ++iInstance )
	{
		context->ExecuteCommandList( perSceneCommandList[iInstance], true );
		SAFE_RELEASE(perSceneCommandList[iInstance]);
	}

	//Draw text on main thread
	const float YPlus = 20;
	auto Position = XMFLOAT2(5, 0);
	auto pointerPos = InputManager::pointerState.Position;
	this->spriteBatch->Begin();
	{
		this->spriteBatch->ShowRectangle();

		this->perf->ShowStatus(this->spriteBatch, this->spriteFont, &Position);
		this->spriteBatch->ShowString("Use W \\ S \\ A \\ D \\ Q \\ Z to move camera", &Position, this->spriteFont);
		Position.y += YPlus;
		this->spriteBatch->ShowString("Press Right mouse to rotate camera", &Position, this->spriteFont);
		Position.y += YPlus;
		this->spriteBatch->ShowString("Pointer Position : { X = " + pointerPos.x + ", Y = " + pointerPos.y + " }" ,
			&Position, this->spriteFont);
		Position.y += YPlus;
		this->spriteBatch->ShowString("Camera Position : { X = " + Camera->Position.x + ", Y = " + Camera->Position.y + ", Z = " + Camera->Position.z + " }" ,
			&Position, this->spriteFont);
		Position.y += YPlus;
		this->spriteBatch->ShowString("Camera Angle : { X = " + Camera->Angle.x + ", Y = " + Camera->Angle.y + " }" ,
			&Position, this->spriteFont);

		this->spriteBatch->End();
	}
}