/*
	FOR GETTING MORE INFORMATION ABOUT THIS CODE PLEASE CHECK http://directx11-1-gameprogramming.azurewebsites.net/ 
	THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
	ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
	THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
	PARTICULAR PURPOSE.
    Copyright (c) Microsoft Corporation. All rights reserved

	File Name        : Texture2D.h
	Generated by     : Pooya Eimandar (http://Pooya-Eimandar.com/)
	File Description : Load 2D texture
 */
#pragma once

#include "DDSTextureLoader.h"

using namespace Microsoft::WRL;

ref class Texture2D
{
internal:
	Texture2D();
	void Load(ID3D11ShaderResourceView* shaderResourceView);
	
	static void LoadTexture(Platform::String^ path, _Inout_ Texture2D^ &texture)
	{
		const Platform::Array<byte>^ textureData = DX::ReadFile(path);
		{
			ID3D11ShaderResourceView* srv = nullptr; 
			auto device = DX::GDevice.d3dDevice.Get();

			CreateDDSTextureFromMemory(
				device,
				textureData->Data,
				textureData->Length,
				nullptr,
				&srv);

			texture->Load(srv);
		}
	}
	static Concurrency::task<void> LoadTextureAsync(Platform::String^ path, _Inout_ Texture2D^ &texture)
	{
		return DX::ReadFileAsync(path)
			.then([texture](const Platform::Array<byte>^ textureData)
		{
			ID3D11ShaderResourceView* srv = nullptr;
			auto device = DX::GDevice.d3dDevice.Get();

			CreateDDSTextureFromMemory(
				device,
				textureData->Data,
				textureData->Length,
				nullptr,
				&srv);

			texture->Load(srv);
		});
	}
	static void CreateSampler(const D3D11_FILTER filter, const D3D11_TEXTURE_ADDRESS_MODE Address[3])
	{
		// Once the texture view is created, create a sampler.  This defines how the color
		// for a particular texture coordinate is determined using the relevant texture data.
		D3D11_SAMPLER_DESC samplerDesc;
		ZeroMemory(&samplerDesc, sizeof(samplerDesc));

		samplerDesc.Filter = filter;

		// The sampler does not use anisotropic filtering, so this parameter is ignored.
		samplerDesc.MaxAnisotropy = 0;

		// Specify how texture coordinates outside of the range 0..1 are resolved.
		samplerDesc.AddressU = Address[0];
		samplerDesc.AddressV = Address[1];
		samplerDesc.AddressW = Address[2];

		// Use no special MIP clamping or bias.
		samplerDesc.MipLODBias = 0.0f;
		samplerDesc.MinLOD = 0;
		samplerDesc.MaxLOD = D3D11_FLOAT32_MAX;

		// Don't use a comparison function.
		samplerDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;

		// Border address mode is not used, so this parameter is ignored.
		samplerDesc.BorderColor[0] = 0.0f;
		samplerDesc.BorderColor[1] = 0.0f;
		samplerDesc.BorderColor[2] = 0.0f;
		samplerDesc.BorderColor[3] = 0.0f;

		using namespace DX;
		using namespace Microsoft::WRL;
		
		ComPtr<ID3D11SamplerState> sampler;
		auto hr = GDevice.d3dDevice->CreateSamplerState(&samplerDesc, &sampler);
		ThrowIfFailed(hr);
		GDevice.Samplers.push_back(sampler);
	}

	property ID3D11ShaderResourceView** TextureView
	{
		ID3D11ShaderResourceView** get() 
		{ 
			return this->textureView.GetAddressOf(); 
		}
	}
private:
	ComPtr<ID3D11ShaderResourceView> textureView;
};