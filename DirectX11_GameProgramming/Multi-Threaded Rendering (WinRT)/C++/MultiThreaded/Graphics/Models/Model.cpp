/*
	FOR GETTING MORE INFORMATION ABOUT THIS CODE PLEASE CHECK http://directx11-1-gameprogramming.azurewebsites.net/ 
	THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
	ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
	THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
	PARTICULAR PURPOSE.
    Copyright (c) Microsoft Corporation. All rights reserved

	File Name        : Model.cpp
	Generated by     : Pooya Eimandar (http://Pooya-Eimandar.com/)
	File Description : 
 */
#include "pch.h"
#include "Model.h"
#include "Graphics/Textures/Texture2D.h"
#include "../Shaders/Shader.h"

using namespace Concurrency;
using namespace Platform;
using namespace DirectX;
using namespace DX;
using namespace std;

Model::Model() : loadingComplete(false), stride(sizeof(VertexTypes::VertexPositionNormalTangentColorTexture)), 
	world(XMMATRIX(
	1,0,0,0,
	0,1,0,0,
	0,0,1,0,
	0,0,0,1))
{
}

void Model::Load(FILE* f)
{
	using namespace std;

	vector<task<void>> tasks;

#pragma region Read name of mesh

	this->Name = L"";
	UINT Lenght = 0;
	const UINT UIntSize = sizeof(UINT);

	fread(&Lenght, UIntSize, 1, f);
	if (Lenght > 0)
	{
		vector<wchar_t> name(Lenght);
		fread(&name[0], sizeof(wchar_t), Lenght, f);
		for(auto e : name)
		{
			this->Name += e;
		}
	}

#pragma endregion

#pragma region Load materials

	//How many materials
	Lenght = 0;
	fread(&Lenght, UIntSize, 1, f);
	this->materials.resize(Lenght);

	//Load each material
	for (UINT i = 0; i < Lenght; i++)
	{
		// read material name
		Lenght = 0;
		fread(&Lenght, UIntSize, 1, f);
		if (Lenght > 0)
		{
			vector<wchar_t> matName(Lenght);
			fread(&matName[0], sizeof(wchar_t), Lenght, f);
		}

		// read material's elements
		fread(&this->materials[i].Const.Ambient, sizeof(XMFLOAT4), 1, f);//Ambient
		fread(&this->materials[i].Const.Diffuse, sizeof(XMFLOAT4), 1, f);//Diffuse
		fread(&this->materials[i].Const.Specular, sizeof(XMFLOAT4), 1, f);//Specular
		fread(&this->materials[i].Const.SpecularPower, sizeof(float), 1, f);//SpecularPower
		fread(&this->materials[i].Const.Emissive, sizeof(XMFLOAT4), 1, f);//Emissive
		fread(&this->materials[i].UVTransform, sizeof(XMFLOAT4X4), 1, f);//UVTransform

		auto shader = ref new Shader();
		//Set default input layout
		shader->SetInputLayout(GDevice.defaultLayout.Get());

		// read name of the pixel shader
		Lenght = 0;
		fread(&Lenght, UIntSize, 1, f);
		if (Lenght > 0)
		{
			// Read the pixel shader name
			String^ PSPath = "";
			vector<wchar_t> pixelShaderName(Lenght);
			fread(&pixelShaderName[0], sizeof(wchar_t), Lenght, f);
			for(auto e : pixelShaderName)
			{
				PSPath += e;
			}
			//Load pixel shader
			if (!PSPath->IsEmpty())
			{
				auto iter = GDevice.PixelShaders.find(PSPath);
				if (iter != GDevice.PixelShaders.end())
				{
					shader->SetPixelShader(iter->second);
				}
				else
				{
					auto psPath = wstring(PSPath->Data());
					auto index = psPath.find_last_of('_');
					if (index != std::wstring::npos)
					{
						psPath = psPath.substr(index + 1);
						psPath = psPath.substr(0, psPath.size() - 9);//9 for .dgsl.cso
						psPath.append(L".cso");
					}
					PSPath = ref new String(psPath.c_str());
					Shader::LoadShader(PSPath, ShaderType::PixelShader, VertexDeclaration::NOP, shader);
					GDevice.PixelShaders[PSPath] = shader->PixelShader;
				}
			}
		}
		shader->SetVertexShader(GDevice.defaultVS.Get());
		//Create shader
		this->materials[i].shader = shader;

		// load textures...
		for (int t = 0; t < MaxTextures; t++)
		{
			// read name of texture
			Lenght = 0;
			fread(&Lenght, UIntSize, 1, f);
			if (Lenght > 0)
			{
				// read the texture name
				std::vector<wchar_t> textureFilename(Lenght);
				fread(&textureFilename[0], sizeof(wchar_t), Lenght, f);
				//if texture is not empty
				if(textureFilename[0] != '\0')
				{
					String^ TPath = "";
					for(auto e : textureFilename)
					{
						TPath += e;
					}
					auto tPath = wstring(TPath->Data());
					auto index = tPath.find_last_of('_');
					if (index != std::wstring::npos)
					{
						tPath = tPath.substr(index + 1);
						tPath = tPath.substr(0, tPath.size() - 8);//8 for .dds.dds
						tPath.append(L".dds");
					}

					TPath = ref new String(tPath.c_str());
					this->materials[i].texture = ref new Texture2D();
					//load texture
					tasks.push_back(Texture2D::LoadTextureAsync(TPath, this->materials[i].texture));
				}
			}
		}
	}

#pragma endregion

	// Does this object contains the skeletal animation?
	BYTE isSkeletalDataPresent = FALSE;
	fread(&isSkeletalDataPresent, sizeof(BYTE), 1, f);

	// Read sub mesh info
	Lenght = 0;
	fread(&Lenght, UIntSize, 1, f);
	this->subMeshes.resize(Lenght);
	for (UINT i = 0; i < Lenght; i++)
	{
		fread(&(this->subMeshes[i]), sizeof(SubMesh), 1, f);
	}

#pragma region Read index buffers

	Lenght = 0;
	fread(&Lenght, UIntSize, 1, f);

	this->indexBuffers.resize(Lenght);
	vector<vector<USHORT>> iBuffers(Lenght);
	for (UINT i = 0; i < Lenght; i++)
	{
		UINT ibCount = 0;
		fread (&ibCount, UIntSize, 1, f);
		if (ibCount > 0)
		{
			iBuffers[i].resize(ibCount);

			// read in the index data
			fread(&iBuffers[i][0], sizeof(USHORT), ibCount, f);

#pragma region Create an index buffer

			D3D11_BUFFER_DESC indexBufferDesc;
			ZeroMemory(&indexBufferDesc, sizeof(indexBufferDesc));

			indexBufferDesc.ByteWidth = sizeof(USHORT) * ibCount;
			indexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
			indexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;
			indexBufferDesc.CPUAccessFlags = 0;
			indexBufferDesc.MiscFlags = 0;
			indexBufferDesc.StructureByteStride = 0;

			D3D11_SUBRESOURCE_DATA indexBufferData;
			ZeroMemory(&indexBufferData, sizeof(indexBufferData));
			indexBufferData.pSysMem = &iBuffers[i][0];
			indexBufferData.SysMemPitch = 0;
			indexBufferData.SysMemSlicePitch = 0;

			auto hr = GDevice.d3dDevice->CreateBuffer(&indexBufferDesc, &indexBufferData, &this->indexBuffers[i]);
			ThrowIfFailed(hr);

#pragma endregion

		}
	}

#pragma endregion

#pragma region Read vertex buffers

	Lenght = 0;
	fread(&Lenght, UIntSize, 1, f);
	this->vertexBuffers.resize(Lenght);
	
	vector<vector<VertexTypes::VertexPositionNormalTangentColorTexture>> vBuffers(Lenght);
	for (UINT i = 0; i < Lenght; i++)
	{
		UINT vbCount = 0;
		fread (&vbCount, UIntSize, 1, f);
		if (vbCount > 0)
		{
			vBuffers[i].resize(vbCount);

			// read in the vertex data
			fread(&vBuffers[i][0], sizeof(VertexTypes::VertexPositionNormalTangentColorTexture), vbCount, f);

#pragma region Create a vertex buffer for this data

			D3D11_BUFFER_DESC vertexBufferDesc;
			ZeroMemory(&vertexBufferDesc, sizeof(vertexBufferDesc));
			vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
			vertexBufferDesc.ByteWidth = sizeof(VertexTypes::VertexPositionNormalTangentColorTexture) * vbCount;
			vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
			vertexBufferDesc.CPUAccessFlags = 0;
			vertexBufferDesc.MiscFlags = 0;
			vertexBufferDesc.StructureByteStride = 0;

			D3D11_SUBRESOURCE_DATA vertexBufferData;
			ZeroMemory(&vertexBufferData, sizeof(vertexBufferData));
			vertexBufferData.pSysMem = &vBuffers[i][0];
			vertexBufferData.SysMemPitch = 0;
			vertexBufferData.SysMemSlicePitch = 0;

			auto hr = GDevice.d3dDevice->CreateBuffer(&vertexBufferDesc, &vertexBufferData, &this->vertexBuffers[i]);
			ThrowIfFailed(hr);

#pragma endregion
		}
	}

#pragma endregion

#pragma region Update triangles

	Lenght = this->subMeshes.size();
	for (UINT i = 0; i < Lenght; i++)
	{
		auto subMesh = this->subMeshes[i];
		std::vector<USHORT>& ib = iBuffers[subMesh.IndexBufferIndex];
		std::vector<VertexTypes::VertexPositionNormalTangentColorTexture>& vb = vBuffers[subMesh.VertexBufferIndex];

		for (UINT j = 0; j < ib.size(); j += 3)
		{
			VertexTypes::VertexPositionNormalTangentColorTexture& v0 = vb[ib[j]];
			VertexTypes::VertexPositionNormalTangentColorTexture& v1 = vb[ib[j+1]];
			VertexTypes::VertexPositionNormalTangentColorTexture& v2 = vb[ib[j+2]];

			Triangle tri;
			tri.points[0] = v0.Position;
			tri.points[1] = v1.Position;
			tri.points[2] = v2.Position;

			this->triangles.push_back(tri);
		}
	}

#pragma endregion

	// done with temp buffers
	vBuffers.clear();
	iBuffers.clear();

	// We skipped Reading skinning vertex buffers
	Lenght = 0;
	fread(&Lenght, UIntSize, 1, f);

	// Read bounding sphere
	fread(&this->boundingSphere, sizeof(BoundingSphere), 1, f);

	//No more to read, start performing tasks
	fclose(f);
	f = nullptr;
	when_all(tasks.begin(), tasks.end()).then([this]()
	{
		this->loadingComplete = true;
		this->CObjectVars.Load();
		this->CMaterialVars.Load();
		this->CLightVars.Load();

		CLightVars.Const.ActiveLights = 1;
		CLightVars.Const.AmbientLight =  XMFLOAT4(0.7f, 0.7f, 0.7f, 1.0f);
		CLightVars.Const.IsPointLight[0] = false;
		CLightVars.Const.LightColor[0] = XMFLOAT4(0.8f, 0.8f, 0.8f, 1.0f); 
		CLightVars.Const.LightDirection[0].x = 1;
		CLightVars.Const.LightDirection[0].y = 1;
		CLightVars.Const.LightDirection[0].z = 1;
		CLightVars.Const.LightDirection[0].w = 0;
		CLightVars.Const.LightSpecularIntensity[0].x = 2;
	});
}

void Model::Update(float time)
{
	this->Rotation.x += time;
	this->Rotation.y += time;
	this->Rotation.z += time;
	
	//Update world
	this->world = 
		XMMatrixScaling(1, 1, 1) * 
		XMMatrixRotationX(this->Rotation.x) * 
		XMMatrixRotationY(this->Rotation.y) *
		XMMatrixRotationZ(this->Rotation.z) *
		XMMatrixTranslation(this->Position.x, this->Position.y, this->Position.z);
}

void Model::Render()
{
	Render(GDevice.d3dContext.Get());
}

void Model::Render(ID3D11DeviceContext1* context)
{
	if (!this->loadingComplete) return;

	auto view = Camera->View;
	auto projection = Camera->Projection;

	context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

	for (UINT i = 0; i < this->subMeshes.size(); i++)
	{
		auto submesh = this->subMeshes[i];
		if (submesh.IndexBufferIndex < this->indexBuffers.size() && submesh.VertexBufferIndex < this->vertexBuffers.size())
		{
			UINT offset = 0;
			context->IASetVertexBuffers(0, 1, &this->vertexBuffers[submesh.VertexBufferIndex], &stride, &offset);
			context->IASetIndexBuffer(this->indexBuffers[submesh.IndexBufferIndex], DXGI_FORMAT_R16_UINT, 0);
		}	

		auto _material = this->materials[submesh.MaterialIndex];
		auto _shader = this->materials[submesh.MaterialIndex].shader;

		#pragma region Update Material
		
		memcpy(&CMaterialVars.Const.Ambient, &_material.Const.Ambient, sizeof(_material.Const.Ambient));
		memcpy(&CMaterialVars.Const.Diffuse, &_material.Const.Diffuse, sizeof(_material.Const.Diffuse));
		memcpy(&CMaterialVars.Const.Specular, &_material.Const.Specular, sizeof(_material.Const.Specular));
		memcpy(&CMaterialVars.Const.Emissive, &_material.Const.Emissive, sizeof(_material.Const.Emissive));
		CMaterialVars.Const.SpecularPower = _material.Const.SpecularPower;
		CMaterialVars.Update(context);
		
		#pragma endregion

		#pragma region Update Transform
		
		DirectX::XMMATRIX localToView = world * view;
		
		CObjectVars.Const.LocalToWorld4x4 = XMMatrixTranspose(this->world);
		CObjectVars.Const.LocalToProjected4x4 = XMMatrixTranspose(world * view * projection);
		CObjectVars.Const.WorldToLocal4x4 = XMMatrixTranspose(XMMatrixInverse(nullptr, world));
		CObjectVars.Const.WorldToView4x4 = XMMatrixTranspose(view);
		CObjectVars.Const.UvTransform4x4 = XMMatrixIdentity();
		CObjectVars.Const.EyePosition = Camera->Position;
		CObjectVars.Update(context);

		#pragma endregion

		CLightVars.Update(context);

		_shader->SetConstantBuffer(context, 0, 1, CMaterialVars.GetBuffer());
		_shader->SetConstantBuffer(context, 1, 1, CLightVars.GetBuffer());
		_shader->SetConstantBuffer(context, 2, 1, CObjectVars.GetBuffer());

		_shader->SetTexture2D(context, 0, 1, _material.texture);

		//context->OMSetBlendState(nullptr, nullptr, 0xFFFFFFFF);
		_shader->Apply(context);
		{
			context->DrawIndexed(submesh.PrimCount * 3, submesh.StartIndex, 0);
		}
	}
}

void Model::Unload()
{
	for (UINT i = 0; i < this->materials.size(); i++)
	{
		SAFE_RELEASE(this->materials[i].shader);
	}
}
