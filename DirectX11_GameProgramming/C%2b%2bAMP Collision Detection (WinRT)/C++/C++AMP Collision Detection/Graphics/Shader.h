/*
	FOR GETTING MORE INFORMATION ABOUT THIS CODE PLEASE CHECK http://directx11-1-gameprogramming.azurewebsites.net/
	THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
	ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
	THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
	PARTICULAR PURPOSE.
	Copyright (c) Microsoft Corporation. All rights reserved

	File Name        : Shader.h
	Generated by     : Pooya Eimandar (http://Pooya-Eimandar.com/)
	File Description :
*/

#pragma once

#include "Texture.h"
#include "FrameWork/DXHelper.h"

struct ObjectInfo
{
	static const UINT SizeInByte = 224;

	DirectX::XMFLOAT4X4 World;
	DirectX::XMFLOAT4X4 view;
	DirectX::XMFLOAT4X4 projection;
	DirectX::XMFLOAT3   eye;
	float               time;
	float				TessEdge;
	float				TessInside;
	DirectX::XMFLOAT2	NOP;

	Microsoft::WRL::ComPtr<ID3D11Buffer> CBuffer;
	HRESULT Load(Graphics3D G3D)
	{
		D3D11_BUFFER_DESC bufferDesc;
		ZeroMemory(&bufferDesc, sizeof(D3D11_BUFFER_DESC));
		bufferDesc.ByteWidth = SizeInByte;
		bufferDesc.Usage = D3D11_USAGE_DEFAULT;
		bufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
		return G3D.device->CreateBuffer(&bufferDesc, nullptr, &this->CBuffer);
	}
	void Update(Graphics3D G3D)
	{
		G3D.context->UpdateSubresource(this->CBuffer.Get(), 0, nullptr, this, 0, 0 );
	}
};

struct LightInfo
{
	static const UINT SizeInByte = 96;

	DirectX::XMFLOAT4 LPos;
	DirectX::XMFLOAT3 La;
	DirectX::XMFLOAT3 Ld;
	DirectX::XMFLOAT3 Ls;	
	DirectX::XMFLOAT3 Ka;
	DirectX::XMFLOAT3 Kd;
	DirectX::XMFLOAT3 Ks;
	float SpecPower;
	float NOP;

	Microsoft::WRL::ComPtr<ID3D11Buffer> CBuffer;

	HRESULT Load(Graphics3D G3D)
	{
		D3D11_BUFFER_DESC bufferDesc;
		ZeroMemory(&bufferDesc, sizeof(D3D11_BUFFER_DESC));
		bufferDesc.ByteWidth = SizeInByte;
		bufferDesc.Usage = D3D11_USAGE_DEFAULT;
		bufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
		return G3D.device->CreateBuffer(&bufferDesc, nullptr, &this->CBuffer);
	}
	void Update(Graphics3D G3D)
	{
		G3D.context->UpdateSubresource(this->CBuffer.Get(), 0, nullptr, this, 0, 0 );
	}
};

struct PixelColor
{
	static const UINT SizeInByte = 16;

	DirectX::XMFLOAT4 BaseColor;

	Microsoft::WRL::ComPtr<ID3D11Buffer> CBuffer;

	HRESULT Load(Graphics3D G3D)
	{
		D3D11_BUFFER_DESC bufferDesc;
		ZeroMemory(&bufferDesc, sizeof(D3D11_BUFFER_DESC));
		bufferDesc.ByteWidth = SizeInByte;
		bufferDesc.Usage = D3D11_USAGE_DEFAULT;
		bufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
		return G3D.device->CreateBuffer(&bufferDesc, nullptr, &this->CBuffer);
	}
	void Update(Graphics3D G3D)
	{
		G3D.context->UpdateSubresource(this->CBuffer.Get(), 0, nullptr, this, 0, 0 );
	}
};

ref class Shader
{
internal:
	//Constructor 
	Shader(Graphics3D G3D, bool CreateLight);

	Concurrency::task<void> LoadAsync(Platform::String^ VSFileName, Platform::String^ PSFileName);
	Concurrency::task<void> LoadAsync(Platform::String^ VSFileName, Platform::String^ PSFileName,
		Platform::String^ GSFileName, Platform::String^ HSFileName, Platform::String^ DSFileName, VertexTypes::Types vertexType);

	void SetObjectInfoCB();
	void SetLightInfoCB();
	void SetPixelColorCB();
	void Apply();
	void SetParameter(Texture^ texture, UINT StartSLot, UINT NumViews);	
	void CreateLayout( Platform::Array<byte>^ VSBytes, const D3D11_INPUT_ELEMENT_DESC* LayoutDesc, UINT sizeInBytes );
	void Unload();

	ObjectInfo* objectInfo;
	LightInfo*  lightInfo;
	PixelColor* pixelColor;
private:
	bool createLight;
	Graphics3D G3D;
	Microsoft::WRL::ComPtr<ID3D11InputLayout> inputLayout;
	Microsoft::WRL::ComPtr<ID3D11VertexShader> vertexShader;
	Microsoft::WRL::ComPtr<ID3D11GeometryShader> geometryShader;
	Microsoft::WRL::ComPtr<ID3D11HullShader> hullShader;
	Microsoft::WRL::ComPtr<ID3D11DomainShader> domainShader;
	Microsoft::WRL::ComPtr<ID3D11PixelShader> pixelShader;
};