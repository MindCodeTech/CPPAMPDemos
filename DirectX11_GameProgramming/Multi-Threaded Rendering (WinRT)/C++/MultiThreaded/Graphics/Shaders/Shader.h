/*
	FOR GETTING MORE INFORMATION ABOUT THIS CODE PLEASE CHECK http://directx11-1-gameprogramming.azurewebsites.net/ 
	THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
	ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
	THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
	PARTICULAR PURPOSE.
    Copyright (c) Microsoft Corporation. All rights reserved

	File Name        : Shader.h
	Generated by     : Pooya Eimandar (http://Pooya-Eimandar.com/)
	File Description : The shader manager for the HLSL files
 */
#pragma once

#include <d3d11.h>
#include <wrl/client.h>
#include "Graphics/VertexTypes.h"
#include "Graphics/Textures/Texture2D.h"

using namespace Platform;
using namespace Microsoft::WRL;
using namespace Platform;

enum ShaderType : byte
{
	VertexShader,
	PixelShader,
	GeometryShader,
	DomainShader,
	HullShader,
	ComputeShader
};

ref class Shader
{
internal:
	Shader();
	virtual void CreateVertexShader(const void* bytes, SIZE_T Length, VertexDeclaration VDeclaration);
	virtual void CreatePixelShader(const void* bytes, SIZE_T Length);
	
	virtual void SetVertexShader(_In_ ID3D11VertexShader* VS);
	virtual void SetPixelShader(_In_ ID3D11PixelShader* PS);
	
	void SetConstantBuffer(UINT startSlot, UINT numBuffer, _In_ ID3D11Buffer* CBuffer);
	void SetConstantBuffer(ID3D11DeviceContext1* context, UINT startSlot, UINT numBuffer, _In_ ID3D11Buffer* CBuffer);

	void SetInputLayout(ID3D11InputLayout* value);
	
	void SetTexture2D(UINT StartSLot, UINT NumViews, Texture2D^ texture2D);
	void SetTexture2D(ID3D11DeviceContext1* context, UINT StartSLot, UINT NumViews, Texture2D^ texture2D);

	virtual void Apply();
	virtual void Apply(ID3D11DeviceContext1* context);
	
	void Release();

	static void LoadShader(Platform::String^ path, ShaderType shaderType,
		VertexDeclaration VDeclaration, _Inout_ Shader^ &shader)
	{
		auto bytes = DX::ReadFile(path);

		switch (shaderType)
		{
		case ShaderType::VertexShader:
			shader->CreateVertexShader(bytes->Data, bytes->Length, VDeclaration);
			break;
		case ShaderType::PixelShader:
			shader->CreatePixelShader(bytes->Data, bytes->Length);
			break;
		case ShaderType::GeometryShader:
			//Not implemented 
			break;
		case ShaderType::DomainShader:
			//Not implemented 
			break;
		case ShaderType::HullShader:
			//Not implemented
			break;
		case ShaderType::ComputeShader:
			//Not implemented
			break;
		default:
			throw ref new Exception(0, "Unknown shader type");
		}
	}

	static Concurrency::task<void> LoadShaderAsync(Platform::String^ path, ShaderType shaderType, 
		VertexDeclaration VDeclaration, _Inout_ Shader^ &shader)
	{
		return DX::ReadFileAsync(path)
			.then([shaderType, VDeclaration, shader](Array<byte>^ bytes)
		{
			switch (shaderType)
			{
			case ShaderType::VertexShader:
				shader->CreateVertexShader(bytes->Data, bytes->Length, VDeclaration);
				break;
			case ShaderType::PixelShader:
				shader->CreatePixelShader(bytes->Data, bytes->Length);
				break;
			case ShaderType::GeometryShader:
				//Not implemented 
				break;
			case ShaderType::DomainShader:
				//Not implemented 
				break;
			case ShaderType::HullShader:
				//Not implemented
				break;
			case ShaderType::ComputeShader:
				//Not implemented
				break;
			default:
				throw ref new Exception(0, "Unknown shader type");
			}
		});
	}

	property bool Loaded
	{
		bool get()
		{
			return this->loaded;
		}
		void set(bool _value)
		{
			this->loaded = _value;
		}
	}
	property ID3D11PixelShader* PixelShader
	{
		ID3D11PixelShader* get()
		{
			return this->pShader.Get();
		}
	}

private:
	bool loaded;
	ComPtr<ID3D11InputLayout> inputLayout;
	ComPtr<ID3D11VertexShader> vShader;
	ComPtr<ID3D11PixelShader> pShader;

	HRESULT CreateInputLayout(const D3D11_INPUT_ELEMENT_DESC*, const UINT, const void*, const SIZE_T);
	HRESULT CreateInputLayout(VertexDeclaration, const void*, const SIZE_T);
};