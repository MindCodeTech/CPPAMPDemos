/*
	FOR GETTING MORE INFORMATION ABOUT THIS CODE PLEASE CHECK http://directx11-1-gameprogramming.azurewebsites.net/ 
	THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
	ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
	THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
	PARTICULAR PURPOSE.
    Copyright (c) Microsoft Corporation. All rights reserved

	File Name        : ModelManager.cpp
	Generated by     : Pooya Eimandar (http://Pooya-Eimandar.com/)
	File Description : 
 */
#include "pch.h"
#include "ModelManager.h"
#include "Framework/MathHelper.h"

using namespace Concurrency;
using namespace Platform;
using namespace DirectX;
using namespace MathHelper;

ModelManager::ModelManager() : activeIndex(0)
{
}

void ModelManager::LoadModel(String^ path)
{
	if(path->IsEmpty()) return;

	FILE* f = nullptr;
	_wfopen_s(&f, path->Data(), L"rb"); 
	if (f == nullptr)
	{
		throw ref new Exception(0, "Could not load model on following path : " + path );
	}
	else
	{
		// How many models?
		UINT Lenght = 0;
		fread(&Lenght, sizeof(Lenght), 1, f);
		//Load each mesh
		for (UINT i = 0; i < Lenght; i++)
		{
			auto model = ref new Model();
			model->Load(f);
			this->models.push_back(model);
		}
	}
	if (f != nullptr)
	{
		fclose(f);
	}
}

void ModelManager::UpdateActiveModel(XMFLOAT3 transfome, float Yaw )
{
	if(this->models.size() > 0)
	{
		this->models[activeIndex]->Position = this->models[activeIndex]->Position + transfome;
		this->models[activeIndex]->Rotation.y = Yaw;
	}
}

void ModelManager::UpdateModels( float time )
{
	std::for_each(this->models.begin(), this->models.end(), [&](Model^ m)
	{
		m->Update(time);		
	});
}

void ModelManager::RenderModels()
{
	std::for_each(this->models.begin(), this->models.end(), [](Model^ m)
	{
		m->Render();		
	});
}

void ModelManager::RenderModels(ID3D11DeviceContext1* context)
{
	std::for_each(this->models.begin(), this->models.end(), [context](Model^ m)
	{
		m->Render(context);		
	});
}

void ModelManager::RenderModels(ID3D11DeviceContext1* context, int startIndex, int stopIndex)
{
	auto size = this->models.size();
	if (stopIndex > size) stopIndex = size;
	
	for (int i = startIndex; i< stopIndex; ++i)
	{
		this->models[i]->Render(context);
	}
}
void ModelManager::Unload()
{
	std::for_each(this->models.begin(), this->models.end(), [&](Model^ m)
	{
		m->Unload();		
	});
}