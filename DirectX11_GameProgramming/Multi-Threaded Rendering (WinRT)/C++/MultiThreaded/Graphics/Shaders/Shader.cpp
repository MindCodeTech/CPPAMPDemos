/*
	FOR GETTING MORE INFORMATION ABOUT THIS CODE PLEASE CHECK http://directx11-1-gameprogramming.azurewebsites.net/ 
	THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
	ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
	THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
	PARTICULAR PURPOSE.
    Copyright (c) Microsoft Corporation. All rights reserved

	File Name        : Shader.cpp
	Generated by     : Pooya Eimandar (http://Pooya-Eimandar.com/)
	File Description : 
 */
#include "pch.h"
#include "Shader.h"
#include "Graphics/VertexTypes.h"

using namespace DirectX; 
using namespace Concurrency;
using namespace Platform;
using namespace DX;

Shader::Shader()
{
}

void Shader::CreateVertexShader(const void* bytes, SIZE_T Length, VertexDeclaration VDeclaration)
{
	auto hr = GDevice.d3dDevice->CreateVertexShader(bytes, Length, nullptr, &this->vShader);
	ThrowIfFailed(hr);
	hr = CreateInputLayout(VDeclaration, bytes, Length);
	ThrowIfFailed(hr);
}

void Shader::CreatePixelShader(const void* bytes, SIZE_T Length)
{
	auto hr = GDevice.d3dDevice->CreatePixelShader(bytes, Length, nullptr, &this->pShader);
	ThrowIfFailed(hr);
}

void Shader::SetVertexShader(_In_  ID3D11VertexShader* VS)
{
	this->vShader = VS;
}

void Shader::SetPixelShader(_In_  ID3D11PixelShader* PS)
{
	this->pShader = PS;
}

void Shader::SetConstantBuffer(UINT startSlot, UINT numBuffer, _In_ ID3D11Buffer* CBuffer)
{
	SetConstantBuffer(GDevice.d3dContext.Get(), startSlot, numBuffer, CBuffer);
}

void Shader::SetConstantBuffer(ID3D11DeviceContext1* context, UINT startSlot, UINT numBuffer, _In_ ID3D11Buffer* CBuffer)
{
	context->VSSetConstantBuffers(startSlot, numBuffer, &CBuffer);
	context->PSSetConstantBuffers(startSlot, numBuffer, &CBuffer);
}

void Shader::SetInputLayout(ID3D11InputLayout* value)
{
	this->inputLayout = value;
}

void Shader::SetTexture2D(UINT StartSLot, UINT NumViews, Texture2D^ texture2D)
{
	SetTexture2D(GDevice.d3dContext.Get(), StartSLot, NumViews, texture2D);
}

void Shader::SetTexture2D(ID3D11DeviceContext1* context, UINT StartSLot, UINT NumViews, Texture2D^ texture2D)
{
	if (GDevice.Samplers.size() != 0)
	{
		auto sampler = GDevice.Samplers.at(0).GetAddressOf();
		context->PSSetShaderResources(StartSLot, NumViews, texture2D->TextureView);
		context->PSSetSamplers(StartSLot, NumViews, sampler);
	}
}

void Shader::Apply()
{
	Apply(GDevice.d3dContext.Get());
}

void Shader::Apply(ID3D11DeviceContext1* context)
{
	context->IASetInputLayout(this->inputLayout.Get());
	context->VSSetShader(this->vShader.Get(), nullptr, 0);
	context->PSSetShader(this->pShader.Get(), nullptr, 0);
}

HRESULT Shader::CreateInputLayout(const D3D11_INPUT_ELEMENT_DESC* vertexDesc, const UINT vertexDescLength,
										const void* shaderData, const SIZE_T shaderDataLength)
{
	return GDevice.d3dDevice->CreateInputLayout(
		vertexDesc,
		vertexDescLength,
		shaderData,
		shaderDataLength,
		this->inputLayout.GetAddressOf());
};

HRESULT Shader::CreateInputLayout(VertexDeclaration vertexTypes, const void* shaderData, SIZE_T shaderDataLength)
{
	HRESULT hr = S_OK;
	if (vertexTypes == Position)
	{
		D3D11_INPUT_ELEMENT_DESC vertexDesc[] = 
		{
			{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
		};
		hr = CreateInputLayout(vertexDesc, ARRAYSIZE(vertexDesc), shaderData, shaderDataLength);
	}
	else if( vertexTypes == PositionTexture)
	{
		const D3D11_INPUT_ELEMENT_DESC vertexDesc[] = 
		{
			{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
			{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
		};
		hr = CreateInputLayout(vertexDesc, ARRAYSIZE(vertexDesc), shaderData, shaderDataLength);
	}
	else if( vertexTypes == PositionColor)
	{
		const D3D11_INPUT_ELEMENT_DESC vertexDesc[] = 
		{
			{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
			{ "COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
		};
		hr = CreateInputLayout(vertexDesc, ARRAYSIZE(vertexDesc), shaderData, shaderDataLength);
	}
	else if( vertexTypes == PositionNormalColor)
	{
		const D3D11_INPUT_ELEMENT_DESC vertexDesc[] = 
		{
			{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
			{ "NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
			{ "COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
		};
		hr = CreateInputLayout(vertexDesc, ARRAYSIZE(vertexDesc), shaderData, shaderDataLength);
	}
	else if( vertexTypes == PositionNormalTexture)
	{
		const D3D11_INPUT_ELEMENT_DESC vertexDesc[] = 
		{
			{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
			{ "NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
			{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
		};
		hr = CreateInputLayout(vertexDesc, ARRAYSIZE(vertexDesc), shaderData, shaderDataLength);
	}
	else if( vertexTypes == PositionNormalTextureTangent)
	{
		const D3D11_INPUT_ELEMENT_DESC vertexDesc[] = 
		{
			{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
			{ "NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
			{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
			{ "TANGENT", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
		};
		hr = CreateInputLayout(vertexDesc, ARRAYSIZE(vertexDesc), shaderData, shaderDataLength);
	}
	else if( vertexTypes == PositionNormalTextureTangentBinormal)
	{
		const D3D11_INPUT_ELEMENT_DESC vertexDesc[] = 
		{
			{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
			{ "NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
			{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
			{ "TANGENT", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
			{ "BINORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
		};
		hr = CreateInputLayout(vertexDesc, ARRAYSIZE(vertexDesc), shaderData, shaderDataLength);
	}
	else if( vertexTypes == PositionNormalTangentColorTexture)
	{
		const D3D11_INPUT_ELEMENT_DESC vertexDesc[] =
		{
			{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
			{ "NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
			{ "TANGENT", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
			{ "COLOR", 0, DXGI_FORMAT_B8G8R8A8_UNORM, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
			{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
		};
		hr = CreateInputLayout(vertexDesc, ARRAYSIZE(vertexDesc), shaderData, shaderDataLength);
	}

	else
	{
		hr = S_FALSE;
		throw ref new Exception(0, "Unknown vertex format");
	}
	return hr;
}

void Shader::Release()
{
}
