/*
	FOR GETTING MORE INFORMATION ABOUT THIS CODE PLEASE CHECK http://directx11-1-gameprogramming.azurewebsites.net/
	THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
	ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
	THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
	PARTICULAR PURPOSE.
	Copyright (c) Microsoft Corporation. All rights reserved

	File Name        : Model.cpp
	Generated by     : Pooya Eimandar (http://Pooya-Eimandar.com/)
	File Description :
*/

#include "pch.h"
#include "FrameWork\DXHelper.h"
#include "..\Model.h"
#include "..\Texture.h"

using namespace Concurrency;
using namespace Platform;
using namespace DirectX;
using namespace MathHelper;

Model::Model() : loadingComplete(false), IsCollide(false), stride(sizeof(VertexTypes::VertexPositionNormalTangentColorTexture)), 
	Color(XMFLOAT4(0, 0, 0.2f, 0)),
	world(XMFLOAT4X4(
	1,0,0,0,
	0,1,0,0,
	0,0,1,0,
	0,0,0,1))
{
	this->bumpMapPath = L"Assets\\Textures\\default_normal.dds";
	this->specMapPath = L"Assets\\Textures\\default_spec.dds";
}

void Model::Load(Graphics3D G3D, Shader^ DefaultShader, FILE* f)
{
	std::vector<task<void>> tasks;

#pragma region Read name of mesh

	this->Name = "";
	UINT Lenght = 0;
	const UINT UIntSize = sizeof(UINT);

	fread(&Lenght, UIntSize, 1, f);
	if (Lenght > 0)
	{
		std::vector<wchar_t> Name(Lenght);
		fread(&Name[0], sizeof(wchar_t), Lenght, f);
		for(auto e : Name)
		{
			this->Name += e;
		}
	}

#pragma endregion

#pragma region Load materials

	//How many materials
	Lenght = 0;
	fread(&Lenght, UIntSize, 1, f);
	this->materials.resize(Lenght);

	//Load each material
	for (UINT i = 0; i < this->materials.size(); i++)
	{
		// read material name
		Lenght = 0;
		fread(&Lenght, UIntSize, 1, f);
		if (Lenght > 0)
		{
			std::vector<wchar_t> matName(Lenght);
			fread(&matName[0], sizeof(wchar_t), Lenght, f);
		}

		// read material's elements
		XMFLOAT4 material;
		XMFLOAT4X4 UV;
		float SpecularPower;
		fread(&material, sizeof(XMFLOAT4), 1, f);//Ambient
		fread(&material, sizeof(XMFLOAT4), 1, f);//Diffuse
		fread(&material, sizeof(XMFLOAT4), 1, f);//Specular
		fread(&SpecularPower, sizeof(float), 1, f);//SpecularPower
		fread(&material, sizeof(XMFLOAT4), 1, f);//Emissive
		fread(&UV, sizeof(XMFLOAT4X4), 1, f);//UV

		// read name of the pixel shader
		Lenght = 0;
		fread(&Lenght, UIntSize, 1, f);
		if (Lenght > 0)
		{
			// Read the pixel shader name
			String^ PSPath = "";
			std::vector<wchar_t> pixelShaderName(Lenght);
			fread(&pixelShaderName[0], sizeof(wchar_t), Lenght, f);
			//Do not need pixel shader
		}

		//Create shader
		this->materials[i].shader = DefaultShader;

		// load textures...
		for (int t = 0; t < MaxTextures; t++)
		{
			// read name of texture
			Lenght = 0;
			fread(&Lenght, UIntSize, 1, f);
			if (Lenght > 0)
			{
				// read the texture name
				std::vector<wchar_t> textureFilename(Lenght);
				fread(&textureFilename[0], sizeof(wchar_t), Lenght, f);
				//if texture is not empty
				if(textureFilename[0] != '\0')
				{
					String^ Name = "";
					for(auto e : textureFilename)
					{
						Name += e;
					}
					this->materials[i].texture = ref new Texture();
					this->materials[i].bumpMap = ref new Texture();
					this->materials[i].specularMap = ref new Texture();
					//load texture
					auto _task = this->materials[i].texture->LoadAsync(G3D, Name);
					tasks.push_back(_task);
					//Load bump map
					_task = this->materials[i].bumpMap->LoadAsync(G3D, this->bumpMapPath);
					tasks.push_back(_task);
					//Load spec map
					_task = this->materials[i].specularMap->LoadAsync(G3D, this->specMapPath);
					tasks.push_back(_task);
				}
			}
		}
	}

#pragma endregion

	// Does this object contain skeletal animation?
	BYTE isSkeletalDataPresent = FALSE;
	fread(&isSkeletalDataPresent, sizeof(BYTE), 1, f);

	// Read sub mesh info
	Lenght = 0;
	fread(&Lenght, UIntSize, 1, f);
	this->subMeshes.resize(Lenght);
	for (UINT i = 0; i < Lenght; i++)
	{
		fread(&(this->subMeshes[i]), sizeof(SubMesh), 1, f);
	}

#pragma region Read index buffers

	Lenght = 0;
	fread(&Lenght, UIntSize, 1, f);
	this->indexBuffers.resize(Lenght);

	std::vector<std::vector<USHORT>> iBuffers(Lenght);
	for (UINT i = 0; i < Lenght; i++)
	{
		UINT ibCount = 0;
		fread (&ibCount, UIntSize, 1, f);
		if (ibCount > 0)
		{
			iBuffers[i].resize(ibCount);

			// read in the index data
			fread(&iBuffers[i][0], sizeof(USHORT), ibCount, f);

#pragma region Create an index buffer

			D3D11_BUFFER_DESC indexBufferDesc;
			ZeroMemory(&indexBufferDesc, sizeof(indexBufferDesc));

			indexBufferDesc.ByteWidth = sizeof(USHORT) * ibCount;
			indexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
			indexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;
			indexBufferDesc.CPUAccessFlags = 0;
			indexBufferDesc.MiscFlags = 0;
			indexBufferDesc.StructureByteStride = 0;

			D3D11_SUBRESOURCE_DATA indexBufferData;
			ZeroMemory(&indexBufferData, sizeof(indexBufferData));
			indexBufferData.pSysMem = &iBuffers[i][0];
			indexBufferData.SysMemPitch = 0;
			indexBufferData.SysMemSlicePitch = 0;

			auto hr = G3D.device->CreateBuffer(&indexBufferDesc, &indexBufferData, &this->indexBuffers[i]);
			DXHelper::ThrowIfFailed(hr);

#pragma endregion

		}
	}

#pragma endregion

#pragma region Read vertex buffers

	Lenght = 0;
	fread(&Lenght, UIntSize, 1, f);
	this->vertexBuffers.resize(Lenght);
	std::vector<std::vector<VertexTypes::VertexPositionNormalTangentColorTexture>> vBuffers(Lenght);
	for (UINT i = 0; i < Lenght; i++)
	{
		UINT vbCount = 0;
		fread (&vbCount, UIntSize, 1, f);
		if (vbCount > 0)
		{
			vBuffers[i].resize(vbCount);

			// read in the vertex data
			fread(&vBuffers[i][0], sizeof(VertexTypes::VertexPositionNormalTangentColorTexture), vbCount, f);

#pragma region Create a vertex buffer for this data

			D3D11_BUFFER_DESC vertexBufferDesc;
			ZeroMemory(&vertexBufferDesc, sizeof(vertexBufferDesc));
			vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
			vertexBufferDesc.ByteWidth = sizeof(VertexTypes::VertexPositionNormalTangentColorTexture) * vbCount;
			vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
			vertexBufferDesc.CPUAccessFlags = 0;
			vertexBufferDesc.MiscFlags = 0;
			vertexBufferDesc.StructureByteStride = 0;

			D3D11_SUBRESOURCE_DATA vertexBufferData;
			ZeroMemory(&vertexBufferData, sizeof(vertexBufferData));
			vertexBufferData.pSysMem = &vBuffers[i][0];
			vertexBufferData.SysMemPitch = 0;
			vertexBufferData.SysMemSlicePitch = 0;

			auto hr = G3D.device->CreateBuffer(&vertexBufferDesc, &vertexBufferData, &this->vertexBuffers[i]);
			DXHelper::ThrowIfFailed(hr);

#pragma endregion
		}
	}

#pragma endregion

#pragma region Update triangles

	Lenght = this->subMeshes.size();
	for (UINT i = 0; i < Lenght; i++)
	{
		auto subMesh = this->subMeshes[i];
		std::vector<USHORT>& ib = iBuffers[subMesh.IndexBufferIndex];
		std::vector<VertexTypes::VertexPositionNormalTangentColorTexture>& vb = vBuffers[subMesh.VertexBufferIndex];

		for (UINT j = 0; j < ib.size(); j += 3)
		{
			VertexTypes::VertexPositionNormalTangentColorTexture& v0 = vb[ib[j]];
			VertexTypes::VertexPositionNormalTangentColorTexture& v1 = vb[ib[j+1]];
			VertexTypes::VertexPositionNormalTangentColorTexture& v2 = vb[ib[j+2]];

			Triangle tri;
			tri.points[0] = v0.Position;
			tri.points[1] = v1.Position;
			tri.points[2] = v2.Position;

			this->triangles.push_back(tri);
		}
	}

#pragma endregion

	// done with temp buffers
	vBuffers.clear();
	iBuffers.clear();

	// We skipped Reading skinning vertex buffers
	Lenght = 0;
	fread(&Lenght, UIntSize, 1, f);

	// Read bounding sphere
	fread(&this->boundingSphere, sizeof(BoundingSphere), 1, f);

	//No more to read, start performing tasks
	fclose(f);
	f = nullptr;
	when_all(tasks.begin(), tasks.end()).then([this]()
	{
		this->loadingComplete = true;	
	});
}

bool Model::IsCollideWith(Model^ model)
{
	const float debounce = 10.0f;

	auto BSphere = model->boundingSphere;
	
	// Check collision between these bounding spheres
	auto normalVector = this->boundingSphere.Center - BSphere.Center;	
	float distance = abs(Length(normalVector));

	if (distance < (this->boundingSphere.Radius + BSphere.Radius) - debounce)
	{
		this->IsCollide = model->IsCollide = true;
		return true;
	}
	return false;
}

void Model::Update(float time)
{
	//Update world
	/*auto _world = XMMatrixTranspose(XMMatrixIdentity() * XMMatrixRotationX(this->Rotation.x) * XMMatrixRotationY(this->Rotation.y) *  XMMatrixTranslation(this->Position.x, this->Position.y, this->Position.z) );
	XMStoreFloat4x4(&this->world, _world );*/
}

void Model::Render(GraphicsDevice GDevice, DirectX::XMFLOAT4X4 world)
{
	if (!this->loadingComplete) return;

	GDevice.G3D.context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

	for (UINT i = 0; i < this->subMeshes.size(); i++)
	{
		auto submesh = this->subMeshes[i];
		if (submesh.IndexBufferIndex < this->indexBuffers.size() && submesh.VertexBufferIndex < this->vertexBuffers.size())
		{
			UINT offset = 0;
			GDevice.G3D.context->IASetVertexBuffers(0, 1, &this->vertexBuffers[submesh.VertexBufferIndex], &stride, &offset);
			GDevice.G3D.context->IASetIndexBuffer(this->indexBuffers[submesh.IndexBufferIndex], DXGI_FORMAT_R16_UINT, 0);
		}	

		auto _shader = this->materials[submesh.MaterialIndex].shader;

		_shader->objectInfo->World = world;
		_shader->objectInfo->view = GDevice.ViewMatrix;
		_shader->objectInfo->projection = GDevice.ProjectionMatrix;
		_shader->objectInfo->Update(GDevice.G3D);
		_shader->SetObjectInfoCB();

		if (_shader->pixelColor->BaseColor != Color)
		{
			_shader->pixelColor->BaseColor = Color;
			_shader->pixelColor->Update(GDevice.G3D);
		}
		_shader->SetPixelColorCB();

		_shader->SetParameter(this->materials[submesh.MaterialIndex].texture, 0, 1);
		_shader->SetParameter(this->materials[submesh.MaterialIndex].bumpMap, 1, 1);
		_shader->SetParameter(this->materials[submesh.MaterialIndex].specularMap, 2, 1);
		
		GDevice.G3D.context->OMSetBlendState(nullptr, nullptr, 0xFFFFFFFF) ;

		this->materials[submesh.MaterialIndex].shader->Apply();
		{
			GDevice.G3D.context->DrawIndexed(submesh.PrimCount * 3, submesh.StartIndex, 0);
		}
	}
}

void Model::Unload()
{
	for (UINT i = 0; i < this->materials.size(); i++)
	{
		SafeUnload(this->materials[i].shader);
	}
}
