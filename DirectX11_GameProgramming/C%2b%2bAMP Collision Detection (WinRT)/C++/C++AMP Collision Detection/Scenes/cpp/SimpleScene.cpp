/*
	FOR GETTING MORE INFORMATION ABOUT THIS CODE PLEASE CHECK http://directx11-1-gameprogramming.azurewebsites.net/
	THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
	ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
	THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
	PARTICULAR PURPOSE.
	Copyright (c) Microsoft Corporation. All rights reserved

	File Name        : SimpleScene.cpp
	Generated by     : Pooya Eimandar (http://Pooya-Eimandar.com/)
	File Description :
*/

#include "pch.h"
#include "FrameWork\DXHelper.h"
#include "FrameWork\Input\InputManager.h"
#include "..\SimpleScene.h"

using namespace Concurrency;
using namespace DirectX;
using namespace Windows::System;
using namespace MathHelper;

SimpleScene::SimpleScene(Windows::UI::Core::CoreWindow^ coreWindow) : wireFrame(false), Game(coreWindow)
{
	this->loadingComplete = false;
}

void SimpleScene::WindowSizeChanged()
{
	Game::WindowSizeChanged();
}

void SimpleScene::Load()
{
	auto G3D = this->GDevice.G3D;
	auto G2D = this->GDevice.G2D;
	
#pragma region Load Resources

	//Load SpriteBatch
	this->spriteBatch = ref new SpriteBatch(G2D);
	//Load Debugger
	this->debugger = ref new Debugger(G2D);
	//Load Font
	this->spriteFont = ref new SpriteFont();
	this->spriteFont->Load(G2D);
	this->camera = ref new ChaseCamera(this->GDevice.AspectRatio);
	this->camera->Position = XMFLOAT3(0, -0.5f, 2.0f);
	this->GDevice.ProjectionMatrix = this->camera->Projection;

	this->manager = ref new Manager();

#pragma endregion

	this->wireFrameState = this->GDevice.CreateRasterizerState(D3D11_CULL_NONE, D3D11_FILL_WIREFRAME);
	this->solidState = this->GDevice.CreateRasterizerState(D3D11_CULL_NONE, D3D11_FILL_SOLID);
	
	std::vector<task<void>> tasks;
	for (int i = 0; i < MAX_MODELS; i++)
	{
		tasks.push_back(this->manager->LoadModel(this->GDevice, "saucer.cmo", "Assets\\Textures\\saucer_normal.dds",
			"Assets\\Textures\\saucer_spec.dds", XMFLOAT3(i * 30 - 30, 0, 170), XMFLOAT3(0, 0, 0)));
	}
	when_all(tasks.begin(), tasks.end()).then([this] ()
	{
		this->loadingComplete = true;
	});
}

void SimpleScene::Unload()
{
	this->GDevice.Unload();
	SafeUnload(this->manager);
}

void SimpleScene::Update(float TotalTime, float DeltaTime)
{
	this->debugger->Update(TotalTime, DeltaTime);

	this->Time = TotalTime;

	const auto RotationSpeed = XMFLOAT2(0.03f, 0.025f);
	auto transform = XMFLOAT3(0,0,0);

	auto activePos = this->manager->ActivePositionModel;
	auto activeYaw = this->manager->ActiveYawModel;

#pragma region Move model

	if (InputManager::keyboardState.IsKeyDown(VirtualKey::W) || InputManager::gamePadState.IsLeftThumbToUp(0))
	{
		transform = MathHelper::Transform(XMFLOAT3(0, 0, -1.0f), XMMatrixRotationY(activeYaw));
	}
	else if (InputManager::keyboardState.IsKeyDown(VirtualKey::S) || InputManager::gamePadState.IsLeftThumbToDown(0))
	{
		transform = MathHelper::Transform(XMFLOAT3(0, 0, 1.0f), XMMatrixRotationY(activeYaw));
	}

#pragma endregion

#pragma region Rotate model

	if (InputManager::keyboardState.IsKeyDown(VirtualKey::A) || InputManager::gamePadState.IsRightThumbToLeft(0))
	{
		activeYaw += RotationSpeed.y;
	}
	else if (InputManager::keyboardState.IsKeyDown(VirtualKey::D) || InputManager::gamePadState.IsRightThumbToRight(0))
	{
		activeYaw -= RotationSpeed.y;
	}

	this->manager->UpdateActiveModel(transform, activeYaw);
	this->manager->UpdateModels(DeltaTime);

#pragma endregion

	this->camera->Update(activePos, activeYaw);
	this->GDevice.ViewMatrix = this->camera->View;
	this->GDevice.EyeVector = this->camera->Position;
	this->manager->UpdateModels(DeltaTime);
}

void SimpleScene::Render()
{
	const float BackColor[] = { 0.0f, 0.0f, 0.0f, 1.0f };
	const float YPlus = 20;
	auto G3D = this->GDevice.G3D;
	
	G3D.context->OMSetRenderTargets(1, this->renderTargetView.GetAddressOf(), this->depthStencilView.Get() );
	G3D.context->ClearRenderTargetView(this->renderTargetView.Get(), BackColor);
	G3D.context->ClearDepthStencilView(this->depthStencilView.Get(), D3D11_CLEAR_DEPTH, 1.0f, 0 );
		
	//Show models in wire frame mode
	if (this->wireFrame)
	{
		G3D.context->RSSetState(this->wireFrameState);
	}
	else
	{
		G3D.context->RSSetState(this->solidState);
	}

	this->manager->RenderModels(this->GDevice);

	auto pointerPos = InputManager::pointerState.Position;
	auto Position = XMFLOAT2(5, 0);
	this->spriteBatch->Begin();
	{
		this->spriteBatch->ShowRectangle();
		this->debugger->ShowStatus(this->spriteBatch, this->spriteFont, &Position);
		this->spriteBatch->ShowString("Default accelerator : " + this->defaultAcceleratorName, &Position, this->spriteFont);
		Position.y += YPlus;
		this->spriteBatch->ShowString("Total Triangles : " + this->manager->ActiveTotalTriangles, &Position, this->spriteFont);
		Position.y += YPlus;
		this->spriteBatch->ShowString("Use W \\ S \\ LeftThumb to move model", &Position, this->spriteFont);
		Position.y += YPlus;
		this->spriteBatch->ShowString("Use A \\ D \\ RightThumb to change direction of model", &Position, this->spriteFont);
		Position.y += YPlus;
		this->spriteBatch->ShowString("Pointer Position : { X = " + pointerPos.x + ", Y = " + pointerPos.y + " }" ,
			&Position, this->spriteFont);
		Position.y += YPlus;
		this->spriteBatch->ShowString("Camera Position : { X = " + this->camera->Position.x + ", Y = " + this->camera->Position.y + ", Z = " + this->camera->Position.z + " }" ,
			&Position, this->spriteFont);
		Position.y += YPlus;
		this->spriteBatch->End();
	}

	Game::Render();
}